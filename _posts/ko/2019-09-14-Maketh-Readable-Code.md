---
title: 읽기 쉬운 코드를 작성하는 이유
category: hestory
tags: [philosophy]
hidden: true
---

Clean Code에 대한 두가지 시선이 존재한다.

당연한 얘기라는 시선과, 꿈속의 얘기라는 시선이다.

이 글은 전자의 시선에서 후자를 비판하기 위한 글이다.

---
## 언어의 본질은 커뮤니케이션에 있다.

먼저 'Programming Language' 라고 말하는지를 생각해야 한다.

말과 글로 대표되는 '언어'는 본래 소통에 그 본질이 있으며 다시 말해 듣는, 혹은 읽는 사람에게 의사를 명확하게 전달하기 위해 사용한다.

### 저수준언어(Low-Level Language)에서 고수준언어(High-Level language)로의 변화[^1]

이 둘 가지고 얘기한다면, 두가지 모두 '의미를 전달한다'라는 언어의 본질에 충실하다.

다만 전달 대상을 기준으로 구분할 뿐이다. 컴퓨터에 전달하는 언어는 저수준언어, 사람에게 전달하는 언어는 고수준 언어이다.

(아마도) 이 글을 읽는 많은 사람들이 사용하는 언어는 대부분 고수준언어이며, 견해의 차이는 있지만 C++부터 Java, C#, Python, Ruby 등의 대부분의 언어가 고수준언어로 분류된다.

프로그래밍 언어는 흔히 말하기를 저수준언어에서 고수준언어로 발전해왔으며, 이는 프로그래밍언어가 다루는 주요한 소통의 대상이 컴퓨터에서 인간으로 변화해왔다는 것을 의미한다.[^2]

고수준언어를 사용한다면 언어를 사용하는 목적에서 '사람이 읽기 쉬운 깨끗한 코드'는 필수적인 가치가 된다는 얘기가 된다.

### 돌아가는 코드가 중요하지 않다는 얘기가 아니다.

이 얘기를 왜곡해서 '프로그램이 돌아가는게 중요하지!' 라는 논리로 달려드는 사람이 있는데, 그거 안중요하다고 한적 없다.

프로그램 개발은 '분석-설계-구현-테스트-유지보수'로 구성된다. 워터폴 방법론은 이 사이클을 크~~~~게 한번 돌리고, 애자일은 작게 여러번 돌리는 차이에 불과하다.[^3]

순서상 앞에 있는 프로세스는 뒤에 있는 프로세스를 위해 진행한다. 예를 들어 우리가 구현한 코드가 테스트에서 버그가 발견되면, 우리는 구현 프로세스로 다시 돌아가서 수정한다.

테스트에서 문제가 발생한 경우, 이것은 구현이 잘못되었음을 의미하기 떄문이다.

그러면 유지보수에서 문제가 발생하는 경우는 어떨까. 마찬가지로 이것은 이전 단계 어딘가에서 문제가 발생했음을 의미한다.

구현단계의 목적을 달성하는 것은 이후 단계가 부드럽게 돌아갈 수 있도록 하는 하나의 '과정'에 불과하며, 구현 그 자체가 개발 전체를 대체할 수 없다.

따라서 '돌아가는 코드(Working Code)'가 중요한 것은 '구현'을 위함이며, '좋은 코드(Good Code)'가 중요한 것은 '개발'을 위함이다.

다시 한번 강조하자면 **구현은 개발의 일부일 뿐, 구현이 곧 개발일 수는 없다**.

좋은 코드가 필요한 이유는, 이후 유지보수를 담당할 누군가(내가 될 수도 있고)를 위한 '배려'이고, 이 '배려'야 말로 서로 다른 개발자들끼리 협업을 가능하게 하는 기본 자질이다.

## 내 코드는 언제나 틀렸고, 버그[^4]는 반드시 발생한다. 

> 우주에 변하지 않는 유일한 것은 모든 것이 변한다는 진리 뿐이다.
    - 헤라클레이토스(Heraclitus)[^5]

프로그래밍 코드는 다양한 이유에 의해 수정될 수 있다는 점은 우리가 상식으로 알고 있으며 코드를 작성하는데 들어가는 시간의 몇배의 시간과 노력이 필요하다는 점도 익히 강조되어왔다.

코드가 수정되어야 하는 이유는 단순한 작성상의 오류일수도 있고, 요구사항이나 사용자층의 변경으로 인해 '그때는 옳았지만 지금은 아니게 된 경우'도 포함된다.

어떤 코드의 사용빈도가 높고 중요할수록 수정빈도는 높아지며, 반대로 수정되지 않는 코드가 있다면, 그 코드는 사용되지 않는 '죽은' 코드이거나 그에 준하는 상태일 확률이 높다.

### 예시

일기예보는 시간의 흐름에 따라 빈번하게 바뀔 수 있다. 1주일 전에 예측한 오늘 날씨와 어제 예측한 오늘 날씨는 다르고, 오늘 오전에 예측한 오후 날씨는 또 다를 수 있다. 

> 서울 : 오전-추움, 오후-비, 밤-비
    경기북부 : 오전-비, 오후-비, 밤-개임
    경기남부 : 오전-따뜻, 오후-비, 밤-추움
    
예보했던 시각이 가까워지면서 예보 내용이 변경될 수도 있다. 혹은 '저녁' 시간대나 '인천', '강원' 지역의 예보를 추가해야 할 수도 있다.

우리 머릿속에서 이 일기예보를 고치는 것은 어렵지 않다. 하지만 일기예보를 아래와 같이 했다면 어떨까?

> 서울은 내일 아침 춥고 오후부터 밤까지 비가 내리며 경기북부에는 하루종일 비가 오다가 저녁에는 그치며
    경기남부는 오전에도 따뜻하다가 오후에 잠시 비가 내린 후 추워지겠습니다.(하략)
    
여기에 저녁시간대를 추가하거나 다른 지역을 추가하기 위해서는 전체 문장을 읽고 적당한 곳에 내용을 추가해야 하며, 추가한 이후 전체적인 문장의 흐름이 어색하지 않은지 한번 더 확인해서 교정해야 한다.

클린코드와 그렇지 않은 코드는 이러한 부분에서 차이가 발생한다.

## 마치며 

결국 프로그래밍 **언어**로 쓰여진 코드는 '읽고' '고칠 수 있어야' 한다.

코드는 반드시 수정되며, 그러기 위해서 다른 개발자가 읽을 수 있어야 하며 그것을 **목적**으로 쓰여져야 한다.

2년 전쯤 이를 위해 DX(Developer Experience), DI(Developer Interface)와 같은 단어를 사용하려 시도한 적이 있는데, 반년쯤 지나 이 단어들의 사용을 그만두었다.

이유는 간단하다.

내가 작성한 코드의 1차 사용자는 내 옆자리의 동료임을 깨달았고 DX, DI라고 표현했던 것은 결국 UX, UI의 아류에 지나지 않음을 눈치챘기 때문이다.

- 사용자 경험을 고려하듯이 코드를 작성하라.

- 내가 사용자라면 어떨까 프로그램을 테스트하듯이 내 코드를 스스로 리뷰하라.

- 사용자의 반응을 살피듯이 동료의 코드 리뷰를 받아라.

- 베타테스터(혹은 책의 베타리더)의 피드백을 대하듯이 코드리뷰의 피드백을 대하라.

누구나 완벽하지 않고, 그렇기 때문에 나는 '협업'이라는 이름으로 옆자리에 손을 벌린다.

동료는 '사용자'의 입장에서 내 코드를 리뷰해 줄 것이고, 나는 그 피드백을 받아들일 수 있다.

이후에는 동료가 '사용자'인 나에게 리뷰를 요청할 것이고, 나는 거기에 피드백을 해줄 수 있다.

(보통의) 이러한 코드 리뷰 후에는 코드가 하나의 저장소에 통합되고 그 이후 그 코드는 '우리의' 코드가 된다.

---
[^1]: 기우일수도 있지만, 드물게 이 개념을 잘못 이해하고 있는 사람들이 있다. [링크](https://planest.tistory.com/entry/%EA%B3%A0%EC%88%98%EC%A4%80-%EC%96%B8%EC%96%B4%EC%99%80-%EC%A0%80%EC%88%98%EC%A4%80-%EC%96%B8%EC%96%B4)에서 명료하게 설명하고 있다.

[^2]: 저수준언어가 쓸모없다는 얘기로 오해하면 안된다. 저수준언어가 오히려 난이도가 높아서 진입장벽이 높을 뿐..

[^3]: 애자일에 대해서는 [다른 분](https://www.popit.kr/author/tony)이 잘 해주시겠지.. 라고 슬그머니 떠넘겨 본다. 구디역 근처 소주집에서 애자일을 깨달은지 1년밖에 안돼서 부담스럽다.

[^4]: 개발단계에서 발견되는 버그를 포함한다.

[^5]: 기원전 6세기경의 사람으로 알려져 있으나 상세한 생몰년이 불분명하여 생략한다. 영화 매트릭스에서는 모피어스가 비슷한 대사를 했다.  